const _debug = true;

function main() {
	var string;
	try {
		var tokens = lex('test.pyjs');
		var tree = parse(tokens);

		string = JSON.stringify(
			tree,
			[
				'key',
				'name',
				'message',
				'value',
				'arity',
				'first',
				'second',
				'third',
				'fourth'
			],
			4
		);
		if(_debug) console.log(string);
		evaluate(tree);
	} catch (err) {
		string = JSON.stringify(
			err,
			[
				'name',
				'message',
				'from',
				'to',
				'key',
				'value',
				'arity',
				'first',
				'second',
				'third',
				'fourth'
			],
			4
		);
		console.log(string);
	}
}

function input(a){
	console.log(a)
}
main();
in_array = function(array, e) {
	for (var i = 0; i < array.length && array[i] !== e; i++);
	return !(i === array.length);
};

exports.Eval = function() {
	var scope;

	var original_scope = {
		find_v: function(id) {
			var e = this,
				o;
			while (true) {
				o = e.v[id];
				if (o) {
					return o;
				}
				e = e.parent;
				if (!e) {
					return null;
				}
			}
		},
		find_f: function(id) {
			var e = this,
				o;
			while (true) {
				o = e.f[id];
				if (o) {
					return o;
				}
				e = e.parent;
				if (!e) {
					throw 'Undefined function ' + id + '()';
				}
			}
		},
		def_f: function(id, value) {
			var o = this.f[id];
			if (o) {
				throw 'Redefine function ' + id + '()';
			}
			this.f[id] = { id: id, value: value };
			return this.f[id];
		},
		def_v: function(id, value) {
			this.v[id] = { id: id, value: value };
			return this.v[id];
		},
		pop: function() {
			scope = this.parent;
		}
	};

	var new_scope = function() {
		var s = scope;
		scope = Object.create(original_scope);
		scope.v = {};
		scope.f = {};
		scope.parent = s;

		scope.v['__CONTROL'] = { id: '__CONTROL', value: null };
		scope.v['__rtn'] = { id: '__rtn', value: undefined };

		return scope;
	};

	var matchEval = function(tree) {
		switch (tree.arity) {
			case 'binary':
				return eval_bina(tree);
			case 'ternary':
				return eval_terna(tree);
			case 'unary':
				return eval_una(tree);
			case 'statement':
				return eval_stmt(tree);
			case 'name':
				return scope.find_v(tree.value);
			case 'fname':
				return scope.find_f(tree.value);
			case 'literal':
				return tree.value;
			default:
				throw 'Unknown arity: ' + tree.arity;
		}
	};

	var eval_stmts = function(tree) {
		for (var i = 0; i < tree.length; i++) {
			matchEval(tree[i]);
			if (
				scope.find_v('__CONTROL').value === 'BREAK' ||
				scope.find_v('__CONTROL').value === 'CONTINUE'
			) {
				break;
			}
		}
	};

	var eval_bina = function(tree) {
		switch (tree.value) {
			case '+':
				return getValue(tree.first) + getValue(tree.second);
			case '-':
				return getValue(tree.first) - getValue(tree.second);
			case '*':
				return getValue(tree.first) * getValue(tree.second);
			case '/':
				return getValue(tree.first) / getValue(tree.second);
			case '%':
				return getValue(tree.first) % getValue(tree.second);
			case '&&':
				return getValue(tree.first) && getValue(tree.second);
			case '||':
				return getValue(tree.first) || getValue(tree.second);
			case '==':
				return getValue(tree.first) === getValue(tree.second);
			case '!=':
				return getValue(tree.first) !== getValue(tree.second);
			case '<=':
				return getValue(tree.first) <= getValue(tree.second);
			case '>=':
				return getValue(tree.first) >= getValue(tree.second);
			case '<':
				return getValue(tree.first) < getValue(tree.second);
			case '>':
				return getValue(tree.first) > getValue(tree.second);
			case '=':
				if (matchEval(tree.first) === null) {
					scope.def_v(tree.first.value, 0);
				}
				return (matchEval(tree.first).value = getValue(tree.second));
			case '+=':
				if (matchEval(tree.first) === null) {
					throw 'Undefined variable ' + tree.first.value;
				}
				return (matchEval(tree.first).value += getValue(tree.second));
			case '-=':
				if (matchEval(tree.first) === null) {
					throw 'Undefined variable ' + tree.first.value;
				}
				return (matchEval(tree.first).value -= getValue(tree.second));
			case '[':
				return getValue(tree.first)[getValue(tree.second)];
			case 'in':
				return in_array(getValue(tree.second), getValue(tree.first));
			case '(':
				return eval_func(tree);
			default:
				throw 'Unknown operator: ' + tree.value;
		}
	};

	var eval_func = function(tree) {
		var func = matchEval(tree.first).value;
		var args = [];
		for (var i = 0; i < tree.second.length; i++) {
			args.push(getValue(tree.second[i]));
		}
		return func(args);
	};

	var eval_terna = function(tree) {
		switch (tree.value) {
			case '?':
				return getValue(tree.first)
					? getValue(tree.second)
					: getValue(tree.third);
			default:
				throw 'Unknown operator: ' + tree.value;
		}
	};

	var eval_una = function(tree) {
		var list = [];
		var dic = {};
		switch (tree.value) {
			case '!':
				return !getValue(tree.first);
			case '-':
				return -getValue(tree.first);
			case '[':
				for (var i = 0; i < tree.first.length; i++) {
					list.push(getValue(tree.first[i]));
				}
				return list;
			case '{':
				for (var i = 0; i < tree.first.length; i++) {
					dic[tree.first[i].key] = getValue(tree.first[i]);
				}
				return dic;
			default:
				throw 'Unknown operator: ' + tree.value;
		}
	};

	var eval_stmt = function(tree) {
		switch (tree.value) {
			case 'def':
				return eval_def(tree);
			case 'while':
				return eval_while(tree);
			case 'if':
				return eval_if(tree);
			case 'for':
				return eval_for(tree);
			case 'break':
				return eval_break(tree);
			case 'continue':
				return eval_continue(tree);
			case 'return':
				return eval_return(tree);
			default:
				throw 'Unknown statement: ' + tree.value;
		}
	};

	var eval_def = function(tree) {
		var func = function(args) {
			var rtn;
			new_scope();
			for (var i = 0; i < tree.first.length; i++) {
				scope.def_v(tree.first[i].value, args[i]);
			}
			eval_stmts(tree.second);
			rtn = scope.find_v('__rtn').value;
			scope.pop();
			if (rtn !== undefined) {
				return rtn;
			}
		};
		scope.def_f(tree.name, func);
	};

	var eval_while = function(tree) {
		while (getValue(tree.first)) {
			new_scope();
			eval_stmts(tree.second);
			if (scope.find_v('__CONTROL').value === 'BREAK') {
				scope.pop();
				break;
			}
			scope.pop();
		}
	};

	var eval_if = function(tree) {
		if (getValue(tree.first)) {
			eval_stmts(tree.second);
		} else if (tree.third !== null) {
			if (tree.third.value === 'elif') {
				eval_if(tree.third);
			} else {
				eval_stmts(tree.third);
			}
		}
	};

	var eval_for = function(tree) {
		if (tree.first.value !== 'in') {
			throw 'Unknown for statement';
		}
		var o = getValue(tree.first.second);
		// for (var index = 0; index < o.length; index++) {
		for (var index in o) {
			new_scope();
			scope.def_v(tree.first.first.value, o[index]);
			eval_stmts(tree.second);
			if (scope.find_v('__CONTROL').value === 'BREAK') {
				scope.pop();
				break;
			}
			scope.pop();
		}
	};

	var eval_break = function(tree) {
		scope.def_v('__CONTROL', 'BREAK');
	};

	var eval_continue = function(tree) {
		scope.def_v('__CONTROL', 'CONTINUE');
	};

	var eval_return = function(tree) {
		var first = matchEval(tree.first);
		var value = first.value ? first.value : first;
		scope.find_v('__rtn').value = value;
	};

	var set_print = function() {
		var func = function(args) {
			if (args.length !== 1) {
				throw 'Unexpected arguments in print()';
			}
			console.log(args[0]);
		};
		scope.def_f('print', func);
	};

	// var set_input = function() {
	//     var func = function(args) {
	//         if (args !== null || args !== undefined) {
	//             throw("Unexpected arguments in input()");
	//         }
	//         var input = readlineSync.question();
	//         return input;
	//     }
	// }

	var set_range = function() {
		var func = function(args) {
			if (args.length === 1) {
				var list = [];
				for (var i = 0; i < args[0]; i++) {
					list.push(i);
				}
				return list;
			} else if (args.length < 4 && args.length > 1) {
				var list = [];
				var gap = args[2] ? args[2] : 1;
				for (var i = args[0]; i < args[1]; i += gap) {
					list.push(i);
				}
				return list;
			} else {
				throw 'Unexpected arguments in range()';
			}
		};
		scope.def_f('range', func);
	};

	var set_builtin = function() {
		set_print();
		set_range();
	};

	var getValue = function(tree) {
		var sec = matchEval(tree);
		if (sec === null) {
			throw 'Undefined variable ' + tree.value;
		} else if (sec.value === null || sec.value === undefined) {
			return sec;
		} else {
			return sec.value;
		}
	};

	return function(tree) {
		new_scope();
		set_builtin();
		eval_stmts(tree);
		scope.pop();
	};
};
exports.Lex = function() {
	var fs = require('fs');
	var lex = function(input) {
		var tokens = [],
			c,
			i = 0,
			TotalOfIndent = 0,
			lines = 1;

		var advance = function() {
			return (c = input[++i]);
		};
		var addToken = function(type, value) {
			tokens.push({
				type: type,
				value: value
			});
		};

		var isOperator = function(c, opr) {
				if (!opr) {
					return /[+\-*\/\^%=(),:.!<>\[\]\{\}]/.test(c);
				} else if (/[!=+\-*\/\^%<>]/.test(opr)) {
					return /[=]/.test(c);
				} else {
					return false;
				}
			},
			isDigit = function(c, mode = false) {
				if (mode == false) return /[0-9]/.test(c);
				else if (mode == true) return /[0-9.]/.test(c);
			},
			isWhiteSpace = function(c) {
				return /\s/.test(c);
			},
			isWord = function(c) {
				return typeof c === 'string' && !isOperator(c) && !isWhiteSpace(c);
			},
			isNewline = function(c) {
				return /\n/.test(c);
			},
			isIndentation = function(c) {
				return /\t/.test(c);
			},
			isString = function(c, mode = '') {
				if (mode == '') return /['"]/.test(c);
				else if (mode == "'") return /[']/.test(c);
				else if (mode == '"') return /["]/.test(c);
			},
			isComment = function(c) {
				return /[#]/.test(c);
			};

		var isCorrectNumber = function(num) {
			var numOfDot = 0;
			for (var count = 0; count < num.length; count++)
				if (num[count] == '.') numOfDot++;
			if (numOfDot > 1) return false;
			else return true;
		};

		while (i < input.length) {
			c = input[i];

			if (isNewline(c)) {
				lines++;
				addToken('CONTROL', 'newline');
				advance();

				var subOfIndent = 0;
				while (isIndentation(c)) {
					subOfIndent++;
					advance();
				}
				while (subOfIndent > TotalOfIndent) {
					addToken('CONTROL', 'indent');
					TotalOfIndent++;
				}
				while (subOfIndent < TotalOfIndent) {
					addToken('CONTROL', 'dedent');
					TotalOfIndent--;
				}
				while (isNewline(c) || isIndentation(c) || isWhiteSpace(c)) {
					advance();
				}
			} else if (isWhiteSpace(c)) {
				advance();
			} else if (isOperator(c)) {
				var opr = c;
				while (isOperator(advance(), opr)) opr += c;
				addToken('OPERATOR', opr);
			} else if (isString(c)) {
				var str = c;
				var mode = c;
				while (!isString(advance(), mode) && i < input.length) str += c;
				if (i >= input.length) throw 'String error in line ' + lines;
				str += c;
				addToken('STRING', str.substring(1, str.length - 1));
				advance();
			} else if (isDigit(c)) {
				var num = c;
				while (isDigit(advance(), true)) num += c;
				if (!isCorrectNumber(num))
					throw 'Error number ' + num + ' in line ' + lines;
				addToken('NUMBER', Number(num));
			} else if (isComment(c)) {
				while (!isNewline(c) && i < input.length) {
					advance();
				}
			} else if (isWord(c)) {
				var word = c;
				while (isWord(advance())) word += c;
				addToken('INDETIFIER', word);
			} else throw 'Unrecognized token.';
		}
		if (tokens[tokens.length - 1].value != 'newline') {
			addToken('CONTROL', 'newline');
		}
		while (TotalOfIndent > 0) {
			addToken('CONTROL', 'dedent');
			TotalOfIndent--;
		}
		addToken('CONTROL', 'end');
		return tokens;
	};

	return function(fileName) {
		let data = fs.readFileSync(fileName);
		let result = lex(data.toString());
		return result;
	};
};
exports.Parse = function() {
	var symbol_table = {};
	var token;
	var tokens;
	var token_nr;

	var itself = function() {
		return this;
	};

	var original_symbol = {
		nud: function() {
			throw 'Undefined.';
		},
		led: function(left) {
			throw 'Missing operator.';
		}
	};

	var symbol = function(id, bp) {
		var s = symbol_table[id];
		bp = bp || 0;
		if (s) {
			if (bp >= s.lbp) {
				s.lbp = bp;
			}
		} else {
			s = Object.create(original_symbol);
			s.id = s.value = id;
			s.lbp = bp;
			symbol_table[id] = s;
		}
		return s;
	};

	symbol('(name)').nud = itself;
	symbol('(literal)').nud = itself;
	symbol('(end)');
	symbol('(newline)').nud = itself;
	symbol('(indent)');
	symbol('(dedent)');
	symbol(':');
	symbol(';');
	symbol(')');
	symbol(']');
	symbol('}');
	symbol(',');
	symbol('else');
	symbol('this').nud = function() {
		this.arity = 'this';
		return this;
	};

	var advance = function(id) {
		var a,
			o,
			t,
			v;

		if (id && token.id !== id) {
			throw 'Expected "' + id + '".';
		}
		if (token_nr >= tokens.length) {
			token = symbol_table['(end)'];
			return;
		}

		t = tokens[token_nr];
		token_nr += 1;
		v = t.value;
		a = t.type;
		if (a === 'INDETIFIER') {
			o = symbol_table[v];
			o = o && typeof o !== 'function' ? o : symbol_table['(name)'];
			a = 'name';
		} else if (a === 'OPERATOR') {
			o = symbol_table[v];
			a = 'operator';
			if (!o) {
				throw 'Unknown operator.';
			}
		} else if (a === 'STRING' || a === 'NUMBER') {
			a = 'literal';
			o = symbol_table['(literal)'];
		} else if (a === 'CONTROL') {
			o = symbol_table['(' + v + ')'];
			if (!o) {
				throw 'Unknown control.';
			}
			a = 'control';
		} else {
			throw 'Unexpected token.';
		}
		token = Object.create(o);
		token.value = v;
		token.arity = a;
		return token;
	};

	var expression = function(rbp) {
		var left;
		var t = token;
		advance();
		left = t.nud();
		while (rbp < token.lbp) {
			t = token;
			advance();
			left = t.led(left);
		}
		return left;
	};

	var infix = function(id, bp, led) {
		var s = symbol(id, bp);
		s.led =
			led ||
			function(left) {
				this.first = left;
				this.second = expression(bp);
				this.arity = 'binary';
				return this;
			};
		return s;
	};
	infix('+', 50);
	infix('-', 50);
	infix('*', 60);
	infix('/', 60);
	infix('in', 30);

	infix('.', 80, function(left) {
		this.first = left;
		if (token.arity !== 'name') {
			throw 'Expected a property name.';
		}
		token.arity = 'literal';
		this.second = token;
		this.arity = 'binary';
		advance();
		return this;
	});

	infix('[', 80, function(left) {
		this.first = left;
		this.second = expression(0);
		this.arity = 'binary';
		advance(']');
		return this;
	});

	infix('?', 20, function(left) {
		this.first = left;
		this.second = expression(0);
		advance(':');
		this.third = expression(0);
		this.arity = 'ternary';
		return this;
	});

	infix('(', 50, function(left) {
		var a = [];
		if (left.id === '.' || left.id === '[') {
			this.arity = 'ternary';
			this.first = left.first;
			this.second = left.second;
			this.third = a;
		} else {
			this.arity = 'binary';
			this.first = left;
			this.first.arity = 'fname';
			this.second = a;
			if (
				(left.arity !== 'unary' || left.id !== 'function') &&
				left.arity !== 'name' &&
				left.arity !== 'fname' &&
				left.id !== '(' &&
				left.id !== '&&' &&
				left.id !== '||' &&
				left.id !== '?'
			) {
				throw 'Expected a variable name';
			}
		}
		if (token.id !== ')') {
			while (true) {
				a.push(expression(0));
				if (token.id !== ',') {
					break;
				}
				advance(',');
			}
		}
		advance(')');
		return this;
	});

	var infixr = function(id, bp, led) {
		var s = symbol(id, bp);
		s.led =
			led ||
			function(left) {
				this.first = left;
				this.second = expression(bp - 1);
				this.arity = 'binary';
				return this;
			};
		return s;
	};
	infixr('&&', 30);
	infixr('||', 30);
	infixr('==', 40);
	infixr('!=', 40);
	infixr('<', 40);
	infixr('<=', 40);
	infixr('>', 40);
	infixr('>=', 40);

	var prefix = function(id, nud) {
		var s = symbol(id);
		s.nud =
			nud ||
			function() {
				this.first = expression(70);
				this.arity = 'unary';
				return this;
			};
		return s;
	};
	prefix('!');
	prefix('-');
	prefix('(', function() {
		var e = expression(0);
		advance(')');
		return e;
	});

	prefix('[', function() {
		var a = [];
		if (token.id !== ']') {
			while (true) {
				a.push(expression(0));
				if (token.id !== ',') {
					break;
				}
				advance(',');
			}
		}
		advance(']');
		this.first = a;
		this.arity = 'unary';
		return this;
	});

	prefix('{', function() {
		var a = [],
			n,
			v;
		if (token.id !== '}') {
			while (true) {
				n = token;
				if (n.arity !== 'name' && n.arity !== 'literal') {
					throw 'Bad property name.';
				}
				advance();
				advance(':');
				v = expression(0);
				v.key = n.value;
				a.push(v);
				if (token.id !== ',') {
					break;
				}
				advance(',');
			}
		}
		advance('}');
		this.first = a;
		this.arity = 'unary';
		return this;
	});

	var assignment = function(id) {
		return infix(id, 10, function(left) {
			if (left.id !== '.' && left.id !== '[' && left.arity !== 'name') {
				throw 'Bad lvalue.';
			}
			this.first = left;
			this.second = expression(9);
			this.assignment = true;
			this.arity = 'binary';
			return this;
		});
	};
	assignment('=');
	assignment('+=');
	assignment('-=');

	var constant = function(s, v) {
		var x = symbol(s);
		x.nud = function() {
			this.value = symbol_table[this.id].value;
			this.arity = 'literal';
			return this;
		};
		x.value = v;
		return x;
	};

	constant('true', true);
	constant('false', false);
	constant('null', null);
	constant('pi', 3.141592653589793);
	constant('Object', {});
	constant('Array', []);

	var statement = function() {
		var n = token,
			v;
		if (n.std) {
			advance();
			return n.std();
		}
		v = expression(0);
		// if (!v.assignment && v.value !== "(" && v.value !== "==") {
		//     throw ("Bad expression statement.");
		// }
		advance('(newline)');
		return v;
	};

	var statements = function() {
		var a = [],
			s;
		while (true) {
			if (token.id === '(dedent)' || token.id === '(end)') {
				break;
			}
			s = statement();
			if (s) {
				a.push(s);
			}
		}
		return a.length === 0 ? null : a;
	};

	var block = function() {
		advance('(newline)');
		var t = token;
		advance('(indent)');
		return t.std();
	};

	var stmt = function(s, f) {
		var x = symbol(s);
		x.std = f;
		return x;
	};

	stmt('(indent)', function() {
		var a = statements();
		advance('(dedent)');
		return a;
	});

	stmt('while', function() {
		this.first = expression(0);
		advance(':');
		this.second = block();
		this.arity = 'statement';
		return this;
	});

	stmt('if', function() {
		this.first = expression(0);
		advance(':');
		this.second = block();
		if (token.id === 'else') {
			advance();
			advance(':');
			this.third = block();
		} else if (token.id === 'elif') {
			this.third = statement();
		} else {
			this.third = null;
		}
		this.arity = 'statement';
		return this;
	});

	stmt('elif', function() {
		this.first = expression(0);
		advance(':');
		this.second = block();
		if (token.id === 'else') {
			advance();
			advance(':');
			this.third = block();
		} else if (token.id === 'elif') {
			this.third = statement();
		} else {
			this.third = null;
		}
		this.arity = 'statement';
		return this;
	});

	stmt('for', function() {
		this.first = expression(0);
		advance(':');
		this.second = block();
		this.arity = 'statement';
		return this;
	});

	stmt('break', function() {
		advance('(newline)');
		if (token.id !== '(dedent)') {
			throw 'Unreachable statement.';
		}
		this.arity = 'statement';
		return this;
	});

	stmt('continue', function() {
		advance('(newline)');
		if (token.id !== '(dedent)') {
			throw 'Unreachable statement.';
		}
		this.arity = 'statement';
		return this;
	});

	stmt('return', function() {
		if (token.id !== '(newline)') {
			this.first = expression(0);
		}
		advance('(newline)');
		if (token.id !== '(dedent)') {
			throw 'Unreachable statement.';
		}
		this.arity = 'statement';
		return this;
	});

	stmt('def', function() {
		var a = [];

		// advance();
		if (token.arity !== 'name') {
			throw 'Expected a function name.';
		}
		this.name = token.value;
		advance();

		advance('(');
		if (token.id !== ')') {
			while (true) {
				if (token.arity !== 'name') {
					throw 'Expected a parameter name.';
				}
				a.push(token);
				advance();
				if (token.id !== ',') {
					break;
				}
				advance(',');
			}
		}
		this.first = a;
		advance(')');
		advance(':');
		advance('(newline)');
		advance('(indent)');
		this.second = statements();
		advance('(dedent)');
		this.arity = 'statement';
		return this;
	});

	return function(source) {
		tokens = source;
		// console.log(tokens)
		token_nr = 0;
		advance();
		var s = statements();
		advance('(end)');
		return s;
	};
};
// KEYWORD
//NEWLINE
//INDENT
//DEDENT
//OPERATOR
//STRING
//NUMBER
